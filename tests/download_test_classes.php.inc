<?php
require_once 'XML/RPC.php';
require_once dirname(__FILE__) . DIRECTORY_SEPARATOR . 'PEAR_test_mock_pearweb.php.inc';
$GLOBALS['pearweb'] = new PEAR_test_mock_pearweb;
class test_XML_RPC_Client extends XML_RPC_Client {
    function test_XML_RPC_Client($path, $server)
    {
        $this->_fakepearweb = &$GLOBALS['pearweb'];
        parent::XML_RPC_Client($path, $server);
    }

    function sendPayloadHTTP10($msg, $server, $port, $timeout=0,
                               $username="", $password="")
    {
        // Only create the payload if it was not created previously
        if(empty($msg->payload)) $msg->createPayload();

        $resp = $this->_fakepearweb->receiveXmlrpc($msg->payload, $server);
        
        $resp=$msg->parseResponse($resp);
        return $resp;
    }
}
require_once 'PEAR/Remote.php';

class test_PEAR_Remote extends PEAR_Remote {
    var $_pearweb;
    var $_fakepearweb = true;
    var $_simulateEpi = true;
    function test_PEAR_Remote(&$config)
    {
        $pearweb = &$GLOBALS['pearweb'];
//        include dirname(__FILE__) . DIRECTORY_SEPARATOR . 'download_test.config.inc';
        $this->_pearweb = &$pearweb;
        parent::PEAR_Remote($config);
        $this->_pearweb->setRemote($this);
    }
    
    function parentcall()
    {
        $args = func_get_args();
        $method = array_shift($args);
        switch (count($args)) {
            case 0:
                $result = PEAR_Remote::call_epi($method);
            break;
            case 1:
                $result = PEAR_Remote::call_epi($method, $args[0]);
            break;
            case 2:
                $result = PEAR_Remote::call_epi($method, $args[0], $args[1]);
            break;
            case 3:
                $result = PEAR_Remote::call_epi($method, $args[0], $args[1], $args[2]);
            break;
            case 4:
                $result = PEAR_Remote::call_epi($method, $args[0], $args[1], $args[2], $args[3]);
            break;
            case 5:
                $result = PEAR_Remote::call_epi($method, $args[0], $args[1], $args[2], $args[3], $args[4]);
            break;
            case 6:
                $result = PEAR_Remote::call_epi($method, $args[0], $args[1], $args[2], $args[3], $args[4], $args[5]);
            break;
        }
        return $result;
    }

    function call($method)
    {
        $_args = $args = func_get_args();

        $server_channel = $this->config->get('default_channel');
        $channel = $this->_registry->getChannel($server_channel);
        if ($channel) {
            if (!$channel->supports('xmlrpc', $method)) {
                // check for channel.list, which is implicitly supported for the PEAR channel
                return $this->raiseError("Channel $server_channel does not support xml-rpc method $method");
            }
        } else {
            return $this->raiseError("Unknown channel '$server_channel'");
        }

        array_unshift($_args, $channel); // cache by channel
        $this->cache = $this->getCache($_args);
        $cachettl = $this->config->get('cache_ttl');
        // If cache is newer than $cachettl seconds, we use the cache!
        if ($this->cache !== null && $this->cache['age'] < $cachettl) {
            return $this->cache['content'];
        };
        if ($this->_simulateEpi) {
            $result = call_user_func_array(array(&$this, 'call_epi'), $args);
            if (!PEAR::isError($result)) {
                $this->saveCache($_args, $result);
            };
            return $result;
        }
        if (!@include_once("XML/RPC.php")) {
            return $this->raiseError("For this remote PEAR operation you need to install the XML_RPC package");
        }
        array_shift($args);
        $server_host = $channel->getServer();
        $username = $this->config->get('username');
        $password = $this->config->get('password');
        $eargs = array();
        foreach($args as $arg) {
            $eargs[] = $this->_encode($arg);
        }
        $f = new XML_RPC_Message($method, $eargs);
        if ($this->cache !== null) {
            $maxAge = '?maxAge='.$this->cache['lastChange'];
        } else {
            $maxAge = '';
        }
        $proxy_host = $proxy_port = $proxy_user = $proxy_pass = '';
        if ($proxy = parse_url($this->config->get('http_proxy'))) {
            $proxy_host = @$proxy['host'];
            $proxy_port = @$proxy['port'];
            $proxy_user = @urldecode(@$proxy['user']);
            $proxy_pass = @urldecode(@$proxy['pass']);
        }
        $c = new test_XML_RPC_Client($channel->getPath('xmlrpc') . $channel->getFileName('xmlrpc')
            .$maxAge, $server_host, $channel->getPort(), $proxy_host, $proxy_port, $proxy_user, $proxy_pass);
        if ($username && $password) {
            $c->setCredentials($username, $password);
        }
        if ($this->config->get('verbose') >= 3) {
            $c->setDebug(1);
        }
        $r = $c->send($f);
        if (!$r) {
            return $this->raiseError("XML_RPC send failed");
        }
        $v = $r->value();
        if ($e = $r->faultCode()) {
            if ($e == $GLOBALS['XML_RPC_err']['http_error'] && strstr($r->faultString(), '304 Not Modified') !== false) {
                return $this->cache['content'];
            }
            return $this->raiseError($r->faultString(), $e);
        }

        $result = XML_RPC_decode($v);
        $this->saveCache($_args, $result);
        return $result;
    }

    function call_epi($method)
    {
        $args = func_get_args();
        array_shift($args);
        if ($this->_fakepearweb) {
            $server_channel = $this->config->get('default_channel');
            $channel = $this->_registry->getChannel($server_channel);
            if (count($args)) {
                $result = $this->_pearweb->call($channel->getServer(), $method, $args);
            } else {
                $result = $this->_pearweb->call($channel->getServer(), $method);
            }
        }/* else {
            switch (count($args)) {
                case 0:
                    $result = parent::call($method);
                break;
                case 1:
                    $result = parent::call($method, $args[0]);
                break;
                case 2:
                    $result = parent::call($method, $args[0], $args[1]);
                break;
                case 3:
                    $result = parent::call($method, $args[0], $args[1], $args[2]);
                break;
                case 4:
                    $result = parent::call($method, $args[0], $args[1], $args[2], $args[3]);
                break;
                case 5:
                    $result = parent::call($method, $args[0], $args[1], $args[2], $args[3], $args[4]);
                break;
                case 6:
                    $result = parent::call($method, $args[0], $args[1], $args[2], $args[3], $args[4], $args[5]);
                break;
            }
        }*/
        if (PEAR::isError($result)) {
            return $result;
        }
        return $result;
    }
}

require_once 'PEAR/Installer.php';
class test_PEAR_Installer extends PEAR_Installer {
    function download($packages, $options, &$config, &$installpackages,
                      &$errors, $installed = false, $willinstall = false, $state = false)
    {
        // trickiness: initialize here
        $this->PEAR_Downloader($this->ui, $options, $config);
        $this->_remote = &new test_PEAR_Remote($config);
        $ret = PEAR_Downloader::download($packages);
        $errors = $this->getErrorMsgs();
        $installpackages = $this->getDownloadedPackages();
        trigger_error("PEAR Warning: PEAR_Installer::download() is deprecated " .
                      "in favor of PEAR_Downloader class", E_USER_WARNING);
        return $ret;
    }
    
    function downloadHttp($url, &$ui, $save_dir = '.', $callback = null)
    {
//        return parent::downloadHttp($url, $ui, $save_dir, $callback);
        if ($callback) {
            call_user_func($callback, 'setup', array(&$ui));
        }
        $info = parse_url($url);
        if (!isset($info['scheme']) || $info['scheme'] != 'http') {
            return PEAR::raiseError('Cannot download non-http URL "' . $url . '"');
        }
        if (!isset($info['host'])) {
            return PEAR::raiseError('Cannot download from non-URL "' . $url . '"');
        } else {
            $host = @$info['host'];
            $port = @$info['port'];
            $path = @$info['path'];
        }
        if (isset($this)) {
            $config = &$this->config;
        } else {
            $config = &PEAR_Config::singleton();
        }
        $proxy_host = $proxy_port = $proxy_user = $proxy_pass = '';
        if ($proxy = parse_url($config->get('http_proxy'))) {
            $proxy_host = @$proxy['host'];
            $proxy_port = @$proxy['port'];
            $proxy_user = @$proxy['user'];
            $proxy_pass = @$proxy['pass'];

            if ($proxy_port == '') {
                $proxy_port = 8080;
            }
            if ($callback) {
                call_user_func($callback, 'message', "Using HTTP proxy $host:$port");
            }
        }
        if (empty($port)) {
            $port = 80;
        }
        // use _pearweb to get file
        $retrieved = explode("\n", $this->_remote->_pearweb->receiveHttp($url));
        $headers = array();
        $line = array_shift($retrieved);
        while (strlen(trim($line))) {
            if (preg_match('/^([^:]+):\s+(.*)\s*$/', $line, $matches)) {
                $headers[strtolower($matches[1])] = trim($matches[2]);
            } elseif (preg_match('|^HTTP/1.[01] ([0-9]{3}) |', $line, $matches)) {
                if ($matches[1] != 200) {
                    return PEAR::raiseError("File http://$host:$port$path not valid (received: $line)");
                }
            }
            $line = array_shift($retrieved);
        }
        $retrieved = join("\n", $retrieved);
        if (isset($headers['content-disposition']) &&
            preg_match('/\sfilename=\"([^;]*\S)\"\s*(;|$)/', $headers['content-disposition'], $matches)) {
            $save_as = basename($matches[1]);
        } else {
            $save_as = basename($url);
        }
        if ($callback) {
            $tmp = call_user_func($callback, 'saveas', $save_as);
            if ($tmp) {
                $save_as = $tmp;
            }
        }
        $dest_file = $save_dir . DIRECTORY_SEPARATOR . $save_as;
        if (!$wp = @fopen($dest_file, 'wb')) {
            fclose($fp);
            if ($callback) {
                call_user_func($callback, 'writefailed', array($dest_file, $php_errormsg));
            }
            return PEAR::raiseError("could not open $dest_file for writing");
        }
        if (isset($headers['content-length'])) {
            $length = $headers['content-length'];
        } else {
            $length = -1;
        }
        $bytes = 0;
        if ($callback) {
            call_user_func($callback, 'start', array(basename($dest_file), $length));
        }
        $start = 0;
        while ($start < strlen($retrieved) - 1) {
            $data = substr($retrieved, $start, 1024);
            $start += 1024;
            $bytes += strlen($data);
            if ($callback) {
                call_user_func($callback, 'bytesread', $bytes);
            }
            if (!@fwrite($wp, $data)) {
                if ($callback) {
                    call_user_func($callback, 'writefailed', array($dest_file, $php_errormsg));
                }
                return PEAR::raiseError("$dest_file: write failed ($php_errormsg)");
            }
        }
        fclose($wp);
        if ($callback) {
            call_user_func($callback, 'done', $bytes);
        }
        return $dest_file;
    }

    function log($level, $msg)
    {
        global $fakelog;
        if (isset($fakelog)) {
            $fakelog->log($level, $msg);
        } else {
            return parent::log($level, $msg);
        }
    }

    function &getDependency2($c, $i, $p, $s)
    {
        $a = &test_PEAR_Dependency2::singleton($c, $i, $p, $s);
        return $a;
    }
}

require_once 'PEAR/Downloader.php';
class test_PEAR_Downloader extends PEAR_Downloader {
    function test_PEAR_Downloader(&$ui, $options, &$config)
    {
        parent::PEAR_Downloader($ui, $options, $config);
        $this->_remote = &new test_PEAR_Remote($config);
    }
    
    function downloadHttp($url, &$ui, $save_dir = '.', $callback = null)
    {
//        return parent::downloadHttp($url, $ui, $save_dir, $callback);
        if ($callback) {
            call_user_func($callback, 'setup', array(&$ui));
        }
        $info = parse_url($url);
        if (!isset($info['scheme']) || $info['scheme'] != 'http') {
            return PEAR::raiseError('Cannot download non-http URL "' . $url . '"');
        }
        if (!isset($info['host'])) {
            return PEAR::raiseError('Cannot download from non-URL "' . $url . '"');
        } else {
            $host = @$info['host'];
            $port = @$info['port'];
            $path = @$info['path'];
        }
        if (isset($this)) {
            $config = &$this->config;
        } else {
            $config = &PEAR_Config::singleton();
        }
        $proxy_host = $proxy_port = $proxy_user = $proxy_pass = '';
        if ($config->get('http_proxy')&& 
              $proxy = parse_url($config->get('http_proxy'))) {
            $proxy_host = @$proxy['host'];
            $proxy_port = @$proxy['port'];
            $proxy_user = @$proxy['user'];
            $proxy_pass = @$proxy['pass'];

            if ($proxy_port == '') {
                $proxy_port = 8080;
            }
            if ($callback) {
                call_user_func($callback, 'message', "Using HTTP proxy $host:$port");
            }
        }
        if (empty($port)) {
            $port = 80;
        }
        // use _pearweb to get file
        $retrieved = explode("\n", $this->_remote->_pearweb->receiveHttp($url));
        $headers = array();
        $line = array_shift($retrieved);
        while (strlen(trim($line))) {
            if (preg_match('/^([^:]+):\s+(.*)\s*$/', $line, $matches)) {
                $headers[strtolower($matches[1])] = trim($matches[2]);
            } elseif (preg_match('|^HTTP/1.[01] ([0-9]{3}) |', $line, $matches)) {
                if ($matches[1] != 200) {
                    return PEAR::raiseError("File http://$host:$port$path not valid (received: $line)");
                }
            }
            $line = array_shift($retrieved);
        }
        $retrieved = join("\n", $retrieved);
        if (isset($headers['content-disposition']) &&
            preg_match('/\sfilename=\"([^;]*\S)\"\s*(;|$)/', $headers['content-disposition'], $matches)) {
            $save_as = basename($matches[1]);
        } else {
            $save_as = basename($url);
        }
        if ($callback) {
            $tmp = call_user_func($callback, 'saveas', $save_as);
            if ($tmp) {
                $save_as = $tmp;
            }
        }
        $dest_file = $save_dir . DIRECTORY_SEPARATOR . $save_as;
        if (!$wp = @fopen($dest_file, 'wb')) {
            if ($callback) {
                call_user_func($callback, 'writefailed', array($dest_file, $php_errormsg));
            }
            return PEAR::raiseError("could not open $dest_file for writing");
        }
        if (isset($headers['content-length'])) {
            $length = $headers['content-length'];
        } else {
            $length = -1;
        }
        $bytes = 0;
        if ($callback) {
            call_user_func($callback, 'start', array(basename($dest_file), $length));
        }
        $start = 0;
        while ($start < strlen($retrieved) - 1) {
            $data = substr($retrieved, $start, 1024);
            $start += 1024;
            $bytes += strlen($data);
            if ($callback) {
                call_user_func($callback, 'bytesread', $bytes);
            }
            if (!@fwrite($wp, $data)) {
                if ($callback) {
                    call_user_func($callback, 'writefailed', array($dest_file, $php_errormsg));
                }
                return PEAR::raiseError("$dest_file: write failed ($php_errormsg)");
            }
        }
        fclose($wp);
        if ($callback) {
            call_user_func($callback, 'done', $bytes);
        }
        return $dest_file;
    }

    /**
     * For simpler unit-testing
     * @param PEAR_Config
     * @param array
     * @param array
     * @param int
     */
    function &getDependency2Object(&$c, $i, $p, $s)
    {
        $z = &new PEAR_Dependency2($c, $i, $p, $s);
        return $z;
    }

    /**
     * For simpler unit-testing
     * @param PEAR_Downloader
     * @return PEAR_Downloader_Package
     */
    function &newDownloaderPackage(&$t)
    {
        $a = new test_PEAR_Downloader_Package($t);
        return $a;
    }

    /**
     * For simpler unit-testing
     * @return string
     */
    function getDownloaderPackageClass()
    {
        return 'test_PEAR_Downloader_Package';
    }

    function log($level, $msg)
    {
        global $fakelog;
        if (isset($fakelog)) {
            $fakelog->log($level, $msg);
        } else {
            return parent::log($level, $msg);
        }
    }
}

require_once 'PEAR/Downloader/Package.php';
class test_PEAR_Downloader_Package extends PEAR_Downloader_Package
{
    function &getDependency2Object($c, $i, $p, $s)
    {
        $a = &test_PEAR_Dependency2::singleton($c, $i, $p, $s);
        return $a; 
    }

    /**
     * For simpler unit-testing
     * @param PEAR_Config
     * @param int
     * @param string
     */
    function &getPackagefileObject(&$c, $d, $dir)
    {
        $a = &new test_PEAR_PackageFile($c, $d, $dir);
        return $a;
    }
}
require_once 'PEAR/Dependency2.php';
class test_PEAR_Dependency2 extends PEAR_Dependency2
{
    var $_fakeOS;
    var $_phpVersion;
    var $_extensions;
    var $_installerVer;

    function &singleton($config = null, $installoptions = null, $package = null,
                              $state = PEAR_VALIDATE_INSTALLING)
    {
        if (!isset($GLOBALS['_test_dep'])) {
            $GLOBALS['_test_dep'] = &new test_PEAR_Dependency2($config,
                $installoptions, $package, $state);
        }
        $a = &new test_PEAR_Dependency2($config, $installoptions, $package, $state);
        $a->setOS(@$GLOBALS['_test_dep']->getSysname());
        $a->setPHPVersion(@$GLOBALS['_test_dep']->phpversion());
        $a->sysname = @$GLOBALS['_test_dep']->sysname;
        $a->release = @$GLOBALS['_test_dep']->release;
        $a->cpu = @$GLOBALS['_test_dep']->cpu;
        $a->extra = @$GLOBALS['_test_dep']->extra;
        $a->nodename = @$GLOBALS['_test_dep']->nodename;
        $a->setPEARVersion(@$GLOBALS['_test_dep']->getPEARVersion());
        $a->setExtensions(@$GLOBALS['_test_dep']->_extensions);
        return $a;
    }

    function setOS($os)
    {
        $this->_fakeOS = $os;
    }

    function getPHP_OS()
    {
        return $this->_fakeOS;
    }

    function getSysname()
    {
        return $this->_fakeOS;
    }

    function setArch($uname, $extra)
    {
        $this->extra = $extra;
        list($this->sysname,
             $this->release,
             $this->cpu,
             $this->extra,
             $this->nodename) = $this->parseSignature($uname, $extra);
    }

    function setPHPversion($version)
    {
        $this->_phpVersion = $version;
    }

    function phpversion($name = null)
    {
        if ($name === null) {
            return $this->_phpVersion;
        } else {
            return $this->extversion($name);
        }
    }

    function setPEARversion($version)
    {
        $this->_installerVer = $version;
    }

    function getPEARVersion()
    {
        return $this->_installerVer;
    }

    function setExtensions($exts)
    {
        $this->_extensions = $exts;
    }

    function parseSignature($uname, $extra)
    {
        static $sysmap = array(
            'HP-UX' => 'hpux',
            'IRIX64' => 'irix',
        );
        static $cpumap = array(
            'i586' => 'i386',
            'i686' => 'i386',
            'ppc' => 'powerpc',
        );
        $parts = split('[[:space:]]+', trim($uname));
        $n = count($parts);

        $release = $machine = $cpu = '';
        $sysname = $parts[0];
        $nodename = $parts[1];
        $cpu = $parts[$n-1];
        $extra = '';
        if ($cpu == 'unknown') {
            $cpu = $parts[$n-2];
        }

        switch ($sysname) {
            case 'AIX' :
                $release = "$parts[3].$parts[2]";
                break;
            case 'Windows' :
                switch ($parts[1]) {
                    case '95/98':
                        $release = '9x';
                        break;
                    default:
                        $release = $parts[1];
                        break;
                }
                $cpu = 'i386';
                break;
            case 'Linux' :
                $extra = $this->_detectGlibcVersion();
                // use only the first two digits from the kernel version
                $release = ereg_replace('^([[:digit:]]+\.[[:digit:]]+).*', '\1', $parts[2]);
                break;
            case 'Mac' :
                $sysname = 'darwin';
                $nodename = $parts[2];
                $release = $parts[3];
                if ($cpu == 'Macintosh') {
                    if ($parts[$n - 2] == 'Power') {
                        $cpu = 'powerpc';
                    }
                }
                break;
            case 'Darwin' :
                if ($cpu == 'Macintosh') {
                    if ($parts[$n - 2] == 'Power') {
                        $cpu = 'powerpc';
                    }
                }
                $release = ereg_replace('^([[:digit:]]+\.[[:digit:]]+).*', '\1', $parts[2]);
                break;
            default:
                $release = ereg_replace('-.*', '', $parts[2]);
                break;
        }


        if (isset($sysmap[$sysname])) {
            $sysname = $sysmap[$sysname];
        } else {
            $sysname = strtolower($sysname);
        }
        if (isset($cpumap[$cpu])) {
            $cpu = $cpumap[$cpu];
        }
        return array($sysname, $release, $cpu, $extra, $nodename);
    }

    function _detectGlibcVersion()
    {
        return $this->extra;
    }

    function matchSignature($match)
    {
        if (is_array($match)) {
            $fragments = $match;
        } else {
            $fragments = explode('-', $match);
        }
        $n = count($fragments);
        $matches = 0;
        if ($n > 0) {
            $matches += $this->_matchFragment($fragments[0], $this->sysname);
        }
        if ($n > 1) {
            $matches += $this->_matchFragment($fragments[1], $this->release);
        }
        if ($n > 2) {
            $matches += $this->_matchFragment($fragments[2], $this->cpu);
        }
        if ($n > 3) {
            $matches += $this->_matchFragment($fragments[3], $this->extra);
        }
        return ($matches == $n);
    }

    function _matchFragment($fragment, $value)
    {
        if (strcspn($fragment, '*?') < strlen($fragment)) {
            $reg = '^' . str_replace(array('*', '?', '/'), array('.*', '.', '\\/'), $fragment) . '$';
            return eregi($reg, $value);
        }
        return ($fragment == '*' || !strcasecmp($fragment, $value));
    }

    function extension_loaded($name)
    {
        return isset($this->_extensions[$name]);
    }

    function extversion($ext)
    {
        if ($this->extension_loaded($ext)) {
            return $this->_extensions[$ext];
        } else {
            return false;
        }
    }
}
require_once 'PEAR/PackageFile.php';
class test_PEAR_PackageFile extends PEAR_PackageFile
{
    function getClassPrefix()
    {
        return 'test_PEAR_PackageFile_v';
    }
}
require_once 'PEAR/PackageFile/v2.php';
class test_PEAR_PackageFile_v2 extends PEAR_PackageFile_v2
{
    function &getPEARDownloader(&$i, $o, &$c)
    {
        $z = &new test_PEAR_Downloader($i, $o, $c);
        $GLOBALS['last_dl'] = &$z;
        return $z;
    }

    function &getPEARDependency2(&$c, $o, $p, $s = PEAR_VALIDATE_INSTALLING)
    {
        $z = &test_PEAR_Dependency2::singleton(&$c, $o, $p, $s);
        return $z;
    }
}
require_once 'PEAR/PackageFile/v1.php';
class test_PEAR_PackageFile_v1 extends PEAR_PackageFile_v1
{
    function &getPEARDownloader(&$i, $o, &$c)
    {
        $z = &new test_PEAR_Downloader($i, $o, $c);
        $GLOBALS['last_dl'] = &$z;
        return $z;
    }

    function &getPEARDependency2(&$c, $o, $p, $s = PEAR_VALIDATE_INSTALLING)
    {
        $z = &test_PEAR_Dependency2::singleton(&$c, $o, $p, $s);
        return $z;
    }
}

class fake_log
{
    var $_log = array();
    var $_download = array();
    function log($level, $message)
    {
        $this->_log[] = array($level, $message);
    }

    function _downloadCallback($msg, $params)
    {
        if ($msg == 'setup') {
            $params = 'self';
        }
        $this->_download[] = array($msg, $params);
    }

    function getLog()
    {
        $log = $this->_log;
        $this->_log = array();
        return $log;
    }

    function getDownload()
    {
        $log = $this->_download;
        $this->_download = array();
        return $log;
    }
}
?>